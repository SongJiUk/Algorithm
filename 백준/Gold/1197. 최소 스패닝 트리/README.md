# 최소 스패닝트리는 Union & Find!
유니온 & 파인드는 진짜 오랜만에 들어봤다. </br>
그래도 예전에 많이 해봐서 금방 풀 수 있었다. </br>
Find함수에서 부모를 찾아주고, Union함수에서 부모를 갱신해주면 된다. </br>
받아줄때 cost값을 기준으로 받아주고 정렬해준다. </br>
그리고 처음부터 넣어줘가면서 count를 늘려주고, 정점의 개수와 같아지면 그게 정답이다. </br>

Union & Find 함수는 외워두는게 좋을것같다.(사실 이미 예전에 외웠었는데 쓸일이없어서, 까먹었다... ㅎ) </br>

int Find(int _x) </br>
{ </br>
  if(parent[_x] == _x) return _x; </br>
  else parent[_x] = Find(parent[_x]); </br>
} </br>

void Union(int _x, int _y) </br>
{ </br>
  _x = Find(_x); </br>
  _y = Find(_y); </br>
 </br>
  if(_x < _y) parent[_y] = _x; </br>
  else parent[_x] = _y;</br>
 }</br>

 머리속에 담아두자!! </br>

# [Gold IV] 최소 스패닝 트리 - 1197 

[문제 링크](https://www.acmicpc.net/problem/1197) 

### 성능 요약

메모리: 6228 KB, 시간: 48 ms

### 분류

최소 스패닝 트리, 그래프 이론

### 제출 일자

2024년 4월 24일 18:11:46

### 문제 설명

<p>그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.</p>

<p>최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.</p>

### 입력 

 <p>첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.</p>

<p>그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다. 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.</p>

### 출력 

 <p>첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.</p>

