# DP문제는 항상 어렵다..
이 문제를 푸려면 DP를 두번 써야되는것같아서 두번 썻다.</br>
처음에 점화식을 찾아보려고 몇시간동안 고민했지만. 쉽지않았고, 힌트를 몇개 보고 아이디어를 얻었다.</br>
일단 힌트를 얻은 점화식은 bool 형식으로 DP를 만들어 bDP[i][j] -> i자리부터 j자리까지가 팰린드롬이면 true를 만들어주는것이다. </br>
그렇게되면 여러번 돌리지않아도 ABA라고하면 0번부터 2번까지는 팰린드롬이니 true로 해서 쉽게 얻을 수 있다.</br>

그리고 난 후 DP[0] = 0, DP[1] = 1로 해서 다음 점화식을 준비했다. 여기서 DP[i] 는 i번 문자열까지의 팰린드롬 개수 최솟값 이다. </br>
나는 이 단계에서 어떻게 돌려줘야 하나 고민했는데. 어차피 bDP[i][j]는 체크를 해줘야했고. </br>
i가 j를 넘어가게 되면 어차피 false값이 있을것이니. j자리의 기준은 k(문자열의 길이)로 잡았고, i자리에는 1부터 k까지의 값을 기준으로 잡았다.</br>
어차피 bDP[i][j]가 true이지 않으면 다음값으로 넘어가니 상관없을 것 같긴했다.</br>

DP문제랑 그리디문제는 풀때마다 새로운것같다. 책에서 이런말을 본적있는데. DP문제를 어렵게 꼬아서내면 제일 어려울거라고... </br>
알고리즘 엄청 큰 책을 사둔게있는데. 그건 또 언제공부할지 모르겠다.. 암튼 백준 플레티넘을 향해서 화이팅해보자 </br>

# [Gold I] 팰린드롬 분할 - 1509 

[문제 링크](https://www.acmicpc.net/problem/1509) 

### 성능 요약

메모리: 8136 KB, 시간: 36 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2024년 3월 12일 13:27:30

### 문제 설명

<p>세준이는 어떤 문자열을 팰린드롬으로 분할하려고 한다. 예를 들어, ABACABA를 팰린드롬으로 분할하면, {A, B, A, C, A, B, A}, {A, BACAB, A}, {ABA, C, ABA}, {ABACABA}등이 있다.</p>

<p>분할의 개수의 최솟값을 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 문자열이 주어진다. 이 문자열은 알파벳 대문자로만 이루어져 있고, 최대 길이는 2,500이다.</p>

### 출력 

 <p>첫째 줄에 팰린드롬 분할의 개수의 최솟값을 출력한다.</p>

