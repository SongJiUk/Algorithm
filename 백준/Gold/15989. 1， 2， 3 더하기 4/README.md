# DP로 풀어보자
DP가 제일어려운거같다... 내 기준
일단 1,2,3을 합쳐서 만들 수 있는 경우의수를 구하는것인데 문제의 조건에 순서만 다른것은 같은것으로 친다고 적혀있다.

처음엔 DFS로 풀면 되지않을까 했는데 최대값이 10000이라 바로 포기했고

한참 고민하다 알고리즘분류에 DP가 적혀있길래 DP로도 고민을 해봤다.
DP문제를 많이 풀어보질 않아서 1차원배열 DP로만 고민을했는데 도저히 모르겠어서 검색을 해보니
1차원 배열 a_n = a_n-3 + (n /2) + 1; 이라는 식으로 할 수 있더라.. 근데 이건 아무리 고민을 해봐도 왜 이런지 모르겠어서
2차원배열로 도전을 해봤다.

a[1][1] => 이 뜻은 값이 1일때 마지막으로 더하는 수가 1이라는 뜻, 경우의수는 1
a[2][1] => 2일때 마지막으로 더하는수가 1일경우의수는 1, a[2][2] = > 2일때 마지막으로 더하는수가 2일경우의수는 1
a[3][1] => 3일때 마지막이 1이면, 경우의수는 1, a[3][2] => 마지막이 2이면 1, a[3][3] => 1 여기까진 값을 쉽게 구할 수 있다.
이제부턴 시작 값이 4일때가 문제.

a[4][1] => 1 a[4][2] => 2 a[4][3] = 1이 된다.
이유는 1은 1111밖에 없고, 2는 112 22 이렇게 있을 수 있고, 3은 13 밖에 없다.(순서가 달라도 다른것으로 치니까)
이걸 점화식으로 나타내 보면

기존 값에서 i를 만들기 위해 더할 수 있는 수가 1인 경우 기존 값의 마지막 수가 1이 되어야 한다.
dp[i][1] = dp[i - 1][1];
기존 값에서 i를 만들기 위해 더할 수 있는 수가 2인 경우 기존 값의 마지막 수가 1 또는 2가 되어야 한다.
dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
기존 값에서 i를 만들기 위해 더할 수 있는 수가 3인 경우 기존 값의 마지막 수가 1 또는 2 또는 3이 되어야 한다.
dp[i][3] = dp[i - 3][1] + dp[i - 3][2] + dp[i - 3][3];

a[i][1] + a[i][2] + a[i][3] 으로 구할 수 있다.


# [Gold V] 1, 2, 3 더하기 4 - 15989 

[문제 링크](https://www.acmicpc.net/problem/15989) 

### 성능 요약

메모리: 2176 KB, 시간: 0 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2024년 2월 23일 16:20:33

### 문제 설명

<p>정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 4가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 합을 이루고 있는 수의 순서만 다른 것은 같은 것으로 친다.</p>

<ul>
	<li>1+1+1+1</li>
	<li>2+1+1 (1+1+2, 1+2+1)</li>
	<li>2+2</li>
	<li>1+3 (3+1)</li>
</ul>

<p>정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 10,000보다 작거나 같다.</p>

### 출력 

 <p>각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.</p>

