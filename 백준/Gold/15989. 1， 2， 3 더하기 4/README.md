# DP로 풀어보자
DP가 제일어려운거같다... 내 기준
일단 1,2,3을 합쳐서 만들 수 있는 경우의수를 구하는것인데 문제의 조건에 순서만 다른것은 같은것으로 친다고 적혀있다.

처음엔 DFS로 풀면 되지않을까 했는데 최대값이 10000이라 바로 포기했고

한참 고민하다 알고리즘분류에 DP가 적혀있길래 DP로도 고민을 해봤다. <br/>
DP문제를 많이 풀어보질 않아서 1차원배열 DP로만 고민을했는데 도저히 모르겠어서 검색을 해보니 <br/>
1차원 배열 a_n = a_n-3 + (n /2) + 1; 이라는 식으로 할 수 있더라.. 근데 이건 아무리 고민을 해봐도 왜 이런지 모르겠어서 2차원배열로 도전을 해봤다.

a[1][1] => 이 뜻은 값이 1일때 마지막으로 더하는 수가 1이라는 뜻, 경우의수는 1 <br/>
a[2][1] => 2일때 마지막으로 더하는수가 1일경우의수는 1, a[2][2] = > 2일때 마지막으로 더하는수가 2일경우의수는 1 <br/>
a[3][1] => 3일때 마지막이 1이면, 경우의수는 1, a[3][2] => 마지막이 2이면 1, a[3][3] => 1 여기까진 값을 쉽게 구할 수 있다.<br/>
이제부턴 시작 값이 4일때가 문제. <br/>

a[4][1] => 1 a[4][2] => 2 a[4][3] = 1이 된다. <br/>
이유는 1은 1111밖에 없고, 2는 112 22 이렇게 있을 수 있고, 3은 13 밖에 없다.(순서가 달라도 다른것으로 치니까) <br/>

기존 값에서 i를 만들기 위해 더할 수 있는 수가 1인 경우 기존 값의 마지막 수가 1이 되어야 한다. <br/>
dp[i][1] = dp[i - 1][1]; <br/>
기존 값에서 i를 만들기 위해 더할 수 있는 수가 2인 경우 기존 값의 마지막 수가 1 또는 2가 되어야 한다. <br/>
dp[i][2] = dp[i - 2][1] + dp[i - 2][2]; <br/>
기존 값에서 i를 만들기 위해 더할 수 있는 수가 3인 경우 기존 값의 마지막 수가 1 또는 2 또는 3이 되어야 한다. <br/>
dp[i][3] = dp[i - 3][1] + dp[i - 3][2] + dp[i - 3][3]; <br/>

a[i][1] + a[i][2] + a[i][3] 으로 구할 수 있다. <br/>

# DP...
완전탐색, DFS, BFS와같이 경우의수를 따져봐야하는데 수행시간을 단축하고자 만들어진 알고리즘 메모리를 사용해서 중복연산을 줄이고 <br/>
중복연산을 줄여서 수행시간을 줄인다. 한번 연산한 결과를 배열에 담는다. <br/>

1. DFS / BFS로 풀 수 있지만 연산수가 너무 많을때 (DFS나 완전탐색의 마지노선은 500만) <br/>
2. 경우의 수들에 중복연산이 많은경우 <br/>
3. 문제 해결 접근방법(DP식 사고방식을 습득해야함) - 30분 고민해보고 안되면 풀이보기 (어떻게하면 뒤로 돌아가지 않을 수 있을까?, 어떤식으로 누적하지?, 어떤 정보를 담아야 이전단계로 돌아가지 않을지) <br/>


결론 : 많이 풀어봐여ㅑ함...


# [Gold V] 1, 2, 3 더하기 4 - 15989 

[문제 링크](https://www.acmicpc.net/problem/15989) 

### 성능 요약

메모리: 2176 KB, 시간: 0 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2024년 2월 23일 16:20:33

### 문제 설명

<p>정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 4가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 합을 이루고 있는 수의 순서만 다른 것은 같은 것으로 친다.</p>

<ul>
	<li>1+1+1+1</li>
	<li>2+1+1 (1+1+2, 1+2+1)</li>
	<li>2+2</li>
	<li>1+3 (3+1)</li>
</ul>

<p>정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 10,000보다 작거나 같다.</p>

### 출력 

 <p>각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.</p>

