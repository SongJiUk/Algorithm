# 와 어렵다 어려워..
문제를 보자마자 BFS로 풀면 되겠구나 하고 풀기 시작했다. </br>
근데 문제는 isVisit를 어디서 초기화를 해줘야될지 모르겠어서 고민을 해보다가 시간을 너무 잡아먹는거같아서 힌트를 봤다.</br>
힌트를 보니까 3차원배열로 선언해서 벽을 부쉈는지 안부쉈는지 체크를 해줬다. 왜 이런생각을 못했을까 </br>
바로 3차원배열을 선언해서 isVisit도 체크를 해주고, count를 따로 세지않고, isVisit에 값을 넣어줬다. </br>
예를 들자면 isVisit[2][1][0] = isVisit[1][1][0] + 1; 이런식으로. 맨 뒤의 0과 1은 벽을 뚫었는지 안뚫었는지 표시해주는것이다. </br>
만약에 벽을 뚫어줬다면 맨뒤의 배열이 1이되니까 더이상 부수지못하고 0으로만 이동하게된다. </br>
왜 항상 한끗전에서 힌트를 볼까 ㅠㅠ 조금만 더 유연하게 생각하고 행동해야겠다. 다음에 이런 영역의 문제가 나오면 꼭 혼자 해결해보자 </br>

그래도 좀 많은것들을 얻어가는 문제인것같다. 방문처리를 3차원배열로 하는건 처음해봐서 ...ㅎ 

# [Gold III] 벽 부수고 이동하기 - 2206 

[문제 링크](https://www.acmicpc.net/problem/2206) 

### 성능 요약

메모리: 12680 KB, 시간: 56 ms

### 분류

너비 우선 탐색, 그래프 이론, 그래프 탐색

### 제출 일자

2024년 4월 8일 20:27:14

### 문제 설명

<p>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.</p>

<p>만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.</p>

<p>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.</p>

<p>맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.</p>

### 출력 

 <p>첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.</p>

